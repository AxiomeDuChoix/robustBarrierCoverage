import java.util.*;
public class MaxFlowProblem  {
    
    int n; // The number of vertices of our graph
    int[][] adjacencyMatrix; // Its adjacency matrix
    int s; // The source of our flow network
    int t; // And its target
    int maxFlow;
    LinkedList<LinkedList<Integer>> paths;



    static int MAX = Integer.MAX_VALUE;

    public MaxFlowProblem(){ // Empty constructor
    }
    public MaxFlowProblem(int cardV, int[][] mat, int source, int target){ // Constructor
        this.s = source;
        this.t = target;
        this.n = cardV;
        this.adjacencyMatrix = mat;
        this.maxFlow=0;
        this.paths = new LinkedList<LinkedList<Integer>>();
    }
    public boolean findPath(int[][] mat,int[] prec){ // Breadth-first search: if there is a s-t path in G_f (whose matrix is mat), then 
                                                     // this function yields "true" and fills up the "prec" table. We can reconstruct the
                                                     // path by "navigating" the table "prec" upstream.   
        LinkedList<Integer> toVisit = new LinkedList<>(); // A queue which will contain the nodes yet to explore. 
        toVisit.add(this.s);
        boolean[] dejaVu = new boolean[this.n];     // To prevent our BFS from entering infinite loops. 
        dejaVu[this.s]=true;
        prec[this.s]=-1;
        while (!toVisit.isEmpty()){
            int u = toVisit.poll();
            for (int v = 0; v<this.n;v++){
                if ((!dejaVu[v])&&(mat[u][v]>0)){ // If there is a path continuation along the u-v edge, and if v hasn't yet been visited. 
                    toVisit.add(v);
                    dejaVu[v]=true;
                    prec[v]=u;
                }
                if (v==this.t)                  // Once we get to t, we're done. Our algorithm will allow the implementation of Edmonds-Karp,
                                                // because BFS automatically gets the shortest path. 
                    break;
            }
        }
        return (dejaVu[this.t]);                // We didn't fail if we got to visit the target t!
    }
    public int[][] FordFulkerson(){ // Main algorithm
        int[][] f = new int[this.n][this.n]; // We create the flow's matrix
        int[][] mat = new int[this.n][this.n]; // as well as the residual graph's matrix
        for (int i = 0 ;i<this.n ;i++ )   // which we initialize (notice that simply declaring mat = this.adjacencyMatrix results in bizarre memory errors).
            for (int j = 0; j<this.n;j++)
                mat[i][j]=this.adjacencyMatrix[i][j];
        int[] prec = new int[this.n]; // This table will allow us to recover the shortest path generated by BFS. 
        int current, c;               // "current" will denote the current node and "c" will contain the flow increase after one step of Edmonds-Karp.
        while (this.findPath(mat,prec)){    // While there is a s-t path in the residual network G_f
            LinkedList<Integer> current_path = new LinkedList<Integer>();
            c=MAX;
            current = this.t;
            while (prec[current]!=-1){      // We look for c'(P)
                if (current!=this.t)
                    current_path.addFirst(current);
                c=Math.min(c,mat[prec[current]][current]);
                current = prec[current];
            }
            this.maxFlow+=c;                // We increase the overall value of the flow.
            this.paths.add(current_path);   // We add the current path.
            current = this.t;               
            while (prec[current]!=-1){      // We update the flow's matrix and the residual graph's matrix. 
                                            // One interesting point is that if we drop the "ifs", we get an antisymmetric matrix. 
                                            // This comes from the fact that a positive flow along the u-v edge can be seen as a negative flow along
                                            // the v-u edge. But this redundancy can be offset with the conditional statements. 
                
                f[prec[current]][current]+=c;
                f[current][prec[current]]-=c;
                mat[prec[current]][current]-=c; //
                mat[current][prec[current]]+=c;
                current=prec[current];
            }
        }
        for (int i = 0; i<this.n;i++){
                for (int j = 0; j<this.n;j++){
                    if (f[i][j]<0)
                        f[i][j]=0;
                }
        }
        return f;
    }
    public LinkedList<LinkedList<Integer>> MaxNodeDisjointPaths(){
        DiGraphe q1 = new DiGraphe(new MaxFlowProblem(n,adjacencyMatrix,s,t));
        LinkedList<LinkedList<Integer>> temp_paths = q1.MaxNodeDisjointPaths();
        LinkedList<LinkedList<Integer>> resu = new LinkedList<LinkedList<Integer>>();
        LinkedList<Integer> new_path;
        while (!temp_paths.isEmpty()){
            LinkedList<Integer> temp = temp_paths.poll();
            new_path = new LinkedList<Integer>();
            new_path.add(this.s);
            while (!temp.isEmpty()){
                temp.poll();
                new_path.add(temp.poll()/2);
            }
            new_path.add(this.t);
            resu.add(new_path);
        }
        this.maxFlow = q1.maxFlow;
        this.paths = resu;
        return resu;
    }
    public  MaxFlowProblem PowerGraph(int p){
        MaxFlowProblem pg = new MaxFlowProblem();
        pg.s = this.s;
        pg.t = this.t;
        pg.n = this.n;
        pg.adjacencyMatrix = new int[this.n][this.n];
        pg.maxFlow = 0;
        pg.paths = new LinkedList<LinkedList<Integer>>();
        for (int i = 0; i<this.n;i++){
            for (int j = 0; j<this.n;j++){
                pg.adjacencyMatrix[i][j] = Math.min(p,this.adjacencyMatrix[i][j]);
            }
        }
        return pg;
    }
    public int[][] maxKRouteFlow(int maxCap, int k){
        // On raisonne par dichotomie, car on sait que le p cherché se situe entre
        // 0 et maxCap.
        int a = 0;
        int b = maxCap+1;
        int p = (a+b)/2;
        MaxFlowProblem pg;
        int[][] flow;
        int psi;

        while (Math.abs(b-a)>1){
            pg = this.PowerGraph(p);
            pg.FordFulkerson();
            psi = pg.maxFlow-k*p;
            if (psi>=0)
                a=p;
            else
                b = p;
            p = (a+b)/2;
        }
        pg = this.PowerGraph(a);
        flow = pg.FordFulkerson();
        this.maxFlow=pg.maxFlow;
        return flow;
    }
    public int floor(int a, int b){ // computes the floor function of a/b where a and b are positive integers, b>0 and a<=b.
        if (a<b)
            return 0;
        else return 1;
    }
    public int ceil(int a, int b){ // computes the ceiling function of a/b where a and b are positive integers, b>0 and a<=b.
        if (a==0)
            return 0;
        else return 1;
    }
    public int[][] getBinary(int[][] f, int maximumKRouteFlow,int maxCap,int k){
        int[][] mat = new int[this.n][this.n];
        int[][] demands = new int[this.n][this.n];
        int[][] resu = new int[this.n][this.n];
        int nu = maximumKRouteFlow/k;
        for (int i = 0; i<this.n;i++){
            for (int j = 0;j<this.n;j++){
                mat[i][j]=ceil(f[i][j],nu);
                demands[i][j]= floor(f[i][j],nu);
            }
        }
        MaxFlowProblemWithDemands mfpwd = new MaxFlowProblemWithDemands(this.s,this.t,this.n,mat,demands);
        mfpwd.feasibleFlow(resu);
        return resu;

    }
    public Pair<ArrayList<Pair<Integer,int[][]>>,Integer> KRouteFlowDecomposition(int maxCap, int k){
        ArrayList<Pair<Integer,int[][]>> resuL = new ArrayList<Pair<Integer,int[][]>>();
        int[][] f = this.maxKRouteFlow(maxCap,k);
        int resuR = this.maxFlow;
        int max_flow = this.maxFlow;
        int nu = max_flow/k; //à modifier dans CoverageGraph
        int[][] binary_flow;
        int delta1=nu, delta2=nu, delta=nu;
        while ((nu>0)){
            binary_flow = this.getBinary(f,max_flow,maxCap,k);
            for (int i = 0; i<this.n;i++){
                for (int j = 0;j<this.n;j++){
                    if (binary_flow[i][j]==0)
                        delta1 = Math.min(delta1,nu-f[i][j]);
                    if (binary_flow[i][j]==1)
                        delta2 = Math.min(delta2,f[i][j]);
                }
            }
            delta = Math.min(delta1,delta2);
            nu-=delta;
            maxCap-=delta;
            max_flow-=delta*k;
            for (int i = 0;i<this.n;i++)
                for (int j = 0;j<this.n;j++){
                    f[i][j]-=delta*binary_flow[i][j];
                }
            resuL.add(new Pair(delta,binary_flow));
        }
        return new Pair(resuL,resuR);
    }
    public Pair<ArrayList<Triplet<LinkedList<LinkedList<Integer>>,Integer, Integer>>,Integer> robustBarrierCoverage(int maxCap, int k){
        // The idea is to create a list of 3-tuples, each containing as first element a list representing a set of K node-disjoint paths.
        // We call such a list a K-covering configuration. 
        // The second and third elements of each 3-tuple will dictate the scheduling of each K-covering configuration. 
        ArrayList<Triplet<LinkedList<LinkedList<Integer>>,Integer, Integer>> resu = new ArrayList<Triplet<LinkedList<LinkedList<Integer>>,Integer, Integer>>();
        // The first step consists on computing the K-Route Flow decomposition of our coverage graph. 
        Pair<ArrayList<Pair<Integer,int[][]>>,Integer> step1 = this.KRouteFlowDecomposition(maxCap,k);
        ArrayList<Pair<Integer,int[][]>> elementary_k_flows_and_their_lifespan = step1.getLeft();
        int network_lifetime = step1.getRight()/k;
        int lifespan, time = 0;
        int[][] elementary_k_flow;
        LinkedList<LinkedList<Integer>> disjoints_paths;
        MaxFlowProblem flow_problem;

        for (int i = 0; i<elementary_k_flows_and_their_lifespan.size();i++){
            lifespan = elementary_k_flows_and_their_lifespan.get(i).getLeft();
            elementary_k_flow = elementary_k_flows_and_their_lifespan.get(i).getRight();
            flow_problem = new MaxFlowProblem(this.n,elementary_k_flow,this.s,this.t);
            disjoints_paths = flow_problem.MaxNodeDisjointPaths();
            resu.add(new Triplet(disjoints_paths,time,time+lifespan));
            time+=lifespan;
        }
        return new Pair(resu,network_lifetime);
    }
    public static void main(String[] args){
        int[][] mat = new int[6][6];
        mat[0]= new int[]{0,16,13,0,0,0};
        mat[1] = new int[]{0,0,10,12,0,0};
        mat[2] = new int[]{0,4,0,0,14,0};
        mat[3] = new int[]{0,0,9,0,0,20};
        mat[4] = new int[]{0,0,0,7,0,4};
        mat[5]= new int[]{0,0,0,0,0,0};
        MaxFlowProblem mfp = new MaxFlowProblem(6,mat,0,5);
        int[][] f = mfp.FordFulkerson();
        System.out.println("Maximum flow = "+mfp.maxFlow);
        LinkedList<LinkedList<Integer>> paths = mfp.MaxNodeDisjointPaths();
        while (!paths.isEmpty())
            System.out.println(paths.poll());

        System.out.println("SÉPARATION!");
        mat = new int[7][7];
        mat[0]= new int[]{0,1,0,3,0,0,0};
        mat[1] = new int[]{0,0,1,0,3,0,0};
        mat[2] = new int[]{0,2,0,0,0,0,1};
        mat[3] = new int[]{0,0,3,0,0,0,0};
        mat[4] = new int[]{0,0,0,0,0,3,0};
        mat[5]= new int[]{0,0,0,0,0,0,3};
        mat[6]= new int[]{0,0,0,0,0,0,0};
        mfp = new MaxFlowProblem(7,mat,0,6);
        f = mfp.FordFulkerson();
        System.out.println("Maximum flow = "+mfp.maxFlow);
            for (int i = 0; i<7;i++){
                for (int j = 0; j<7;j++){
                    System.out.print(f[i][j]+"          ");
                }
                System.out.println();
            }

        System.out.println("JUGEMENT DERNIER");
        int[][] matrice = {
{0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0},
{0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0},
{0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0},
{0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0},
{1,0,1,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0},
{1,0,0,1,1,0,0,1,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0},
{0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0},
{1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,0,0},
{0,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,1,1,1,1,1,1},
{0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0},
{0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,0,1,1,1},
{0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0},
{0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0},
{0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0},
{0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0},
{0,1,1,1,0,0,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0},
{0,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,1,1},
{0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,1,1,1},
{1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0},
{1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0},
{1,0,0,0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,1,0,0,0},
{0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0},
{1,0,1,1,1,1,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,1,0,1,0,0,0},
{0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,0},
{0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,0,0,0},
{0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,0,1,0,0,0},
{0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0},
{0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,0,0,0,1,0,1,1,1,1},
{0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0},
{0,1,1,0,0,0,1,0,1,1,1,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,1,1},
{0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1},
{0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0}
};
        mfp = new MaxFlowProblem(32,matrice,0,31);
        f = mfp.FordFulkerson();
        System.out.println("Maximum flow = "+mfp.maxFlow);
            for (int i = 0; i<32;i++){
                for (int j = 0; j<32;j++){
                    System.out.print(f[i][j]+" ");
                }
                System.out.println();
            }



    }
};
