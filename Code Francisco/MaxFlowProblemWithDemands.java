import java.util.*;

public class MaxFlowProblemWithDemands extends MaxFlowProblem{

    int[][] d;

    public MaxFlowProblemWithDemands(){
    }
    public  MaxFlowProblemWithDemands(int s, int t, int n, int[][] adjacencyMatrix,int[][] d){ // This constructor creates the modified graph which will allow us to compute M node-disjoint paths. 
        this.s = s;
        this.t = t;
        this.n = n;
        this.adjacencyMatrix = adjacencyMatrix;
        this.d = d;
        this.maxFlow=0;
        this.paths = new LinkedList<LinkedList<Integer>>();
    }
    public  MaxFlowProblemWithDemands(MaxFlowProblem mfp,int[][] d){ // This constructor creates the modified graph which will allow us to compute M node-disjoint paths. 
        this.s = mfp.s;
        this.t = mfp.t;
        this.n = mfp.n;
        this.adjacencyMatrix = mfp.adjacencyMatrix;
        this.d = d;
        this.maxFlow=0;
        this.paths = new LinkedList<LinkedList<Integer>>();
    }
    public boolean feasibleFlow(int [][] resu){
        SurGraphe sg = new SurGraphe(this.s, this.t, this.n, this.adjacencyMatrix, this.d);
        int[][] f_prime = sg.FordFulkerson(); // If we got here, then resu was true.
                                              // Hence sg has a saturating flow.
                                              // But if a flow network has a saturating
                                              // flow, then a maximum flow is necessarily
                                              // saturating, and we can trivially apply 
                                              // Lemma 1. 
        boolean bool = true;
        for (int i = 0; i<n;i++){
            if ((f_prime[i+1][n+1]>0)&&(f_prime[i+1][n+1]<sg.adjacencyMatrix[i+1][n+1])){ // We check whether the flow we just obtained is saturating. 
                bool = false;
                break;
            }
        }

        if (!bool)
            return false;
        for (int i =0;i<n;i++)
            for (int j = 0;j<n;j++)
                resu[i][j]=f_prime[i+1][j+1]+d[i][j];
        resu[this.n-1][0]=0;
        for (int i = 0;i<n;i++)
            this.maxFlow+=resu[i][this.n-1];

        return true;
    }

    public int[][] EdmondsKarpWithDemands(int[][] f, int feasible_flow){
        int[][] mat = new int[this.n][this.n]; // as well as the residual graph's matrix
        for (int i = 0 ;i<this.n ;i++ ){   // which we initialize (notice that simply declaring mat = this.adjacencyMatrix results in bizarre memory errors).
            for (int j = 0; j<this.n;j++){
                if (f[i][j]>0){
                    mat[i][j]=this.adjacencyMatrix[i][j]-f[i][j];
                    mat[j][i]=f[i][j]-d[i][j];

                }
            }
        }
        int[] prec = new int[this.n]; // This table will allow us to recover the shortest path generated by BFS. 
        int current, c;               // "current" will denote the current node and "c" will contain the flow increase after one step of Edmonds-Karp.
        while (this.findPath(mat,prec)){    // While there is a s-t path in the residual network G_f
            LinkedList<Integer> current_path = new LinkedList<Integer>();
            c=MAX;
            current = this.t;
            while (prec[current]!=-1){      // We look for c'(P)
                if (current!=this.t)
                    current_path.addFirst(current);
                c=Math.min(c,mat[prec[current]][current]);
                current = prec[current];
            }
            this.maxFlow+=c;                // We increase the overall value of the flow.
            this.paths.add(current_path);   // We add the current path.
            current = this.t;               
            while (prec[current]!=-1){      // We update the flow's matrix and the residual graph's matrix. 
                                            // One interesting point is that if we drop the "ifs", we get an antisymmetric matrix. 
                                            // This comes from the fact that a positive flow along the u-v edge can be seen as a negative flow along
                                            // the v-u edge. But this redundancy can be offset with the conditional statements. 
                
                f[prec[current]][current]+=c;
                f[current][prec[current]]-=c;
                mat[prec[current]][current]=this.adjacencyMatrix[prec[current]][current]-f[prec[current]][current]; //
                mat[current][prec[current]]=f[prec[current]][current]-this.d[prec[current]][current];
                current=prec[current];
            }
            for (int i = 0; i<this.n;i++){
                for (int j = 0; j<this.n;j++){
                    if (f[i][j]<this.d[i][j])
                        f[i][j]=0;
                }
            }
        }
        System.out.println("MaxFlow="+this.maxFlow);
        return f;
    }
};













